# macOS クリップボード管理アプリ開発調査レポート

## 📋 プロジェクト概要

### 目的
macOS用常駐クリップボード管理アプリの開発を通じて、Swift/macOS開発技術の習得と実用的なアプリケーションの構築

### 技術スタック
- **言語**: Swift 6.1
- **UI フレームワーク**: SwiftUI + AppKit
- **パッケージ管理**: Swift Package Manager
- **対象OS**: macOS 13.0以上
- **データ永続化**: UserDefaults + Codable

### 開発期間
2025/09/06~2025/09/31（継続開発中）

---

## 🔍 技術調査・選定理由

### 開発環境の選定

#### Swift Package Manager vs Xcode Project
**選定理由**: Swift Package Manager (SPM)

**調査結果**:
- **Xcode Project の課題**:
  - `project.pbxproj` ファイルの破損が頻発
  - 複雑な設定管理による不安定性
  - バージョン管理での競合問題

- **SPM の優位性**:
  - シンプルな `Package.swift` による設定管理
  - 高い安定性とメンテナンス性
  - コマンドライン開発の効率性
  - 依存関係の明確な管理

### UI フレームワークの選定

#### SwiftUI vs AppKit のハイブリッドアプローチ
**選定理由**: 用途に応じた最適なフレームワークの選択

**調査結果**:
- **メニューバーアプリ**: AppKit
  - `NSStatusItem`, `NSMenu` の安定性
  - システム統合の容易さ
  - 軽量な実装

- **メインウィンドウ**: SwiftUI
  - モダンなUI構築の効率性
  - リアクティブなデータバインディング
  - 保守性の向上

### データ永続化の選定

#### UserDefaults vs Core Data vs SQLite
**選定理由**: UserDefaults + Codable

**調査結果**:
- **UserDefaults の優位性**:
  - シンプルなデータ構造に最適
  - 軽量性と高速アクセス
  - システム標準の設定管理
  - JSONエンコーディングによる柔軟性

- **他の選択肢の検討**:
  - Core Data: 過剰な複雑性
  - SQLite: 直接的なファイル管理の必要性

---

## 🛠️ 開発プロセス・課題と解決策

### 主要な技術的課題

#### 1. MainActor の競合状態
**問題**:
```swift
// エラー例
main actor-isolated property 'image' can not be mutated from a nonisolated context
```

**解決策**:
```swift
@MainActor
class ClipboardManager: ObservableObject {
    // MainActor属性の追加
    
    private func checkClipboardChanges() {
        Task { @MainActor in
            // UI更新処理
        }
    }
}
```

**学習ポイント**:
- Swift Concurrency の適切な使用
- UI更新のスレッド安全性の確保

#### 2. データ互換性の問題
**問題**:
```swift
// エラー例
keyNotFound(CodingKeys(stringValue: "categoryId", intValue: nil))
```

**解決策**:
```swift
// カスタムデコーダーによる後方互換性
init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    
    // 既存フィールド
    id = try container.decode(UUID.self, forKey: .id)
    content = try container.decode(String.self, forKey: .content)
    
    // 新フィールド（オプショナル）
    categoryId = try container.decodeIfPresent(UUID.self, forKey: .categoryId) 
                ?? Category.defaultCategory.id
}
```

**学習ポイント**:
- バージョン管理とデータ移行戦略
- Codable プロトコルの高度な活用

#### 3. Xcodeプロジェクトの不安定性
**問題**:
- `project.pbxproj` の破損によるビルド失敗
- 設定ファイルの複雑性

**解決策**:
- SPM への完全移行
- シンプルなプロジェクト構造の採用

### UI/UX設計の課題

#### 段階的UI改善アプローチ
**問題**:
- 一度に大幅変更するとアプリクラッシュ
- デバッグの困難性

**解決策**:
1. **第1段階**: 小さなUI改善（色とスペーシング）
2. **第2段階**: ボタンデザインの改善
3. **第3段階**: カードデザインの追加
4. **第4段階**: アニメーションの追加
5. **第5段階**: メニューバーUIの改善
6. **第6段階**: 最終的なデザイン調整

**学習ポイント**:
- 段階的開発によるリスク軽減
- ユーザーフィードバックの活用

#### macOS特有のUI制約
**問題**:
- iOS向けSwiftUIコンポーネントの非対応
- プラットフォーム固有の制約

**解決策**:
```swift
// iOS向けコンポーネントの代替実装
// NavigationView → VStack + カスタムヘッダー
// navigationBarTrailing → ToolbarItem(placement: .primaryAction)
```

---

## 📊 開発進捗

### 完了済み機能
- ✅ **基本クリップボード監視**: 自動履歴保存機能
- ✅ **メニューバー統合**: 常駐アプリとしての実装
- ✅ **履歴管理画面**: SwiftUIによる管理インターフェース
- ✅ **スニペット機能**: お気に入りからスニペットへの進化
- ✅ **フォルダ管理**: カスタムフォルダによる分類
- ✅ **フォルダ編集**: フォルダ名・色の変更機能
- ✅ **スニペット移動**: フォルダ編集画面での移動機能
- ✅ **メニューバーUI改善**: サブメニューによる階層表示
- ✅ **データ永続化**: UserDefaultsによる安全な保存

### 現在の実装状況
- **Phase 1**: UI統一化とコンポーネント整理 ✅
- **Phase 2**: スニペット機能の実装 ✅
- **Phase 3**: フォルダ編集機能の実装 ✅
- **Phase 4**: メニューバーUI改善 ✅
- **Phase 5**: ドキュメント更新 🔄

### 今後の予定
- **Phase 6**: パフォーマンス最適化
- **Phase 7**: 追加機能の実装（検索、タグ等）
- **Phase 8**: 配布準備

---

## ⚙️ 機能実装の詳細

### コア機能

#### クリップボード監視
```swift
private func startClipboardMonitoring() {
    clipboardTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
        Task { @MainActor in
            self?.checkClipboardChanges()
        }
    }
}

private func checkClipboardChanges() {
    let currentCount = NSPasteboard.general.changeCount
    if currentCount != lastClipboardChangeCount {
        lastClipboardChangeCount = currentCount
        // 新しいクリップボード内容の処理
    }
}
```

**技術的特徴**:
- `NSPasteboard.general.changeCount` による効率的な監視
- 1秒間隔でのポーリング
- MainActor による安全なUI更新

#### メニューバー統合
```swift
private func setupStatusBar() {
    statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)
    
    if let button = statusItem?.button {
        button.image = NSImage(systemSymbolName: "doc.on.clipboard.fill")
        button.image?.size = NSSize(width: 18, height: 18)
        button.action = #selector(statusBarButtonClicked)
        button.target = self
    }
}
```

**技術的特徴**:
- `NSStatusItem` による常駐アプリ実装
- システムアイコンの活用
- 動的メニュー構築
- サブメニューによる階層的表示
- 履歴とスニペットの分離表示

#### データ管理
```swift
class ClipboardDataManager: ObservableObject {
    @Published var historyItems: [ClipboardItem] = []
    @Published var favoriteItems: [ClipboardItem] = [] // スニペット
    @Published var favoriteFolders: [FavoriteFolder] = []
    
    // スニペット移動機能
    func moveSnippetsToFolder(_ snippetIds: [UUID], to folderId: UUID) {
        for snippetId in snippetIds {
            if let index = favoriteItems.firstIndex(where: { $0.id == snippetId }) {
                favoriteItems[index].favoriteFolderId = folderId
            }
        }
        saveData()
    }
}
```

**技術的特徴**:
- `ObservableObject` によるリアクティブデータフロー
- `@Published` プロパティによる自動UI更新
- 階層的なデータ構造
- スニペット移動機能の実装
- データ整合性の自動修正

### 拡張機能

#### カテゴリシステム
- カスタムカテゴリの作成・編集・削除
- 色分けによる視覚的な分類
- デフォルトカテゴリの提供

#### スニペットフォルダ
- 階層的なスニペット整理
- フォルダ別の表示・管理
- フォルダ編集画面でのスニペット移動機能
- 12色のカラーパレットによる視覚的分類

#### スニペット管理
- 直接スニペット登録・編集機能
- スニペット説明フィールド
- フォルダなしスニペットの管理
- チェックボックスによる複数選択移動

#### フォルダ編集画面
```swift
struct FolderEditView: View {
    let folder: FavoriteFolder
    @Binding var editedName: String
    @Binding var editedColor: String
    let dataManager: ClipboardDataManager
    
    @State private var selectedSnippets: Set<UUID> = []
    @State private var showingMoveDialog = false
    
    // フォルダなしのスニペット表示
    private var unassignedSnippets: [ClipboardItem] {
        dataManager.favoriteItems.filter { $0.favoriteFolderId == nil }
    }
}
```

**技術的特徴**:
- モーダルシートによる編集画面
- チェックボックスによる複数選択
- 確認ダイアログによる安全な操作
- リアルタイムUI更新

#### 検索・フィルタリング
- リアルタイム検索
- フォルダ別フィルタリング
- スニペット内容での検索

---

## 🚀 パフォーマンス・最適化

### メモリ管理

#### 履歴制限
```swift
private func addToHistory(_ content: String) {
    let newItem = ClipboardItem(content: content)
    historyItems.insert(newItem, at: 0)
    
    // 50件の上限設定
    if historyItems.count > 50 {
        historyItems = Array(historyItems.prefix(50))
    }
}
```

**最適化効果**:
- メモリ使用量の制御
- パフォーマンスの維持
- ユーザビリティの向上

#### 遅延読み込み
```swift
ScrollView {
    LazyVStack(spacing: 12) {
        ForEach(Array(filteredHistoryItems.enumerated()), id: \.element.id) { index, item in
            HistoryItemRow(item: item)
                .transition(.asymmetric(
                    insertion: .scale.combined(with: .opacity),
                    removal: .scale.combined(with: .opacity)
                ))
                .animation(.easeInOut(duration: 0.3).delay(Double(index) * 0.05), 
                          value: filteredHistoryItems.count)
        }
    }
}
```

**最適化効果**:
- 大量データの効率的表示
- メモリ使用量の削減
- スムーズなスクロール

### UI応答性

#### 非同期処理
- バックグラウンドでのクリップボード監視
- MainActor による安全なUI更新
- ブロッキング処理の回避

#### アニメーション最適化
- 適切な継続時間（0.2-0.3秒）
- 自然なイージング関数
- パフォーマンスを考慮したトランジション

---

## 🔒 セキュリティ・プライバシー考慮

### データ保護

#### ローカル保存
- 外部送信なしの完全ローカル処理
- UserDefaults による安全なデータ保存
- 暗号化の検討（将来実装予定）

#### 権限最小化
- 必要最小限のシステム権限のみ要求
- クリップボードアクセスのみ
- ネットワークアクセスなし

### ユーザー体験

#### 透明性
- データの保存場所の明確化
- 使用方法の説明
- プライバシーポリシーの提供

#### 制御性
- ユーザーによる完全なデータ管理
- 履歴の削除機能
- 設定のカスタマイズ

---

## 🧪 テスト・品質保証

### テスト戦略

#### 段階的テスト
1. **単体テスト**: 各機能の個別テスト
2. **統合テスト**: 全体機能の動作確認
3. **ユーザビリティテスト**: 実際の使用シナリオでの検証

#### テスト項目
- **機能テスト**: 全機能の正常動作確認
- **パフォーマンステスト**: メモリ使用量・応答性
- **互換性テスト**: 異なるmacOSバージョンでの動作
- **ストレステスト**: 大量データでの動作確認

### 品質指標

#### 安定性
- クラッシュのない動作
- メモリリークの防止
- エラーハンドリングの充実

#### パフォーマンス
- 軽量な常駐アプリ（メモリ使用量 < 50MB）
- 高速な応答性（< 100ms）
- 効率的なデータ処理

#### ユーザビリティ
- 直感的な操作感
- 適切なフィードバック
- アクセシビリティの考慮

---

## 🔮 今後の改善案

### 機能拡張

#### ドラッグ&ドロップ ✅
- ファイルや画像の対応
- 外部アプリケーションとの連携
- 複数アイテムの一括操作
- スニペット間の移動機能
- スニペットの並び替え機能

#### ショートカットキー ✅
- キーボード操作の強化
- カスタムショートキーの設定
- グローバルホットキーの対応（Cmd+Option+C）
- マウス位置でのメニュー表示機能

#### クラウド同期
- iCloud連携による複数デバイス同期
- エンドツーエンド暗号化
- オフライン対応

### 技術的改善

#### UI/UX改善 ✅
- フォルダアイコンの改善（丸からファイルアイコンへ）
- 不要なボタンの削除によるUI簡素化
- 視認性と直感性の向上

#### SwiftUI完全移行
- macOS 14+での新機能活用
- よりモダンなUIコンポーネント
- パフォーマンスの向上

#### パフォーマンス最適化
- より効率的なデータ処理
- メモリ使用量の削減
- バッテリー消費の最適化

#### アクセシビリティ
- VoiceOver対応の強化
- キーボードナビゲーション
- 高コントラストモード対応

---

## 📚 学習成果・技術的知見

### Swift開発の知見

#### Swift Concurrency
- MainActor の適切な使用
- Task による非同期処理
- 競合状態の回避

#### SwiftUI + AppKit
- ハイブリッドアプローチの実践
- プラットフォーム固有の制約への対応
- 最適なフレームワークの選択

#### データ永続化
- Codable プロトコルの活用
- バージョン管理とデータ移行
- エラーハンドリングの実装

### macOS開発の知見

#### メニューバーアプリ
- 常駐アプリの実装パターン
- システム統合の方法
- ユーザー体験の設計

#### システム統合
- クリップボードAPIの活用
- システム権限の管理
- バックグラウンド処理の実装

#### UI/UX設計
- macOS向けデザインガイドライン
- ネイティブアプリの実装
- アクセシビリティの考慮

---

## 📊 結論・総括

### プロジェクトの成果

#### 技術的目標
- ✅ 安定した常駐クリップボード管理アプリの完成
- ✅ Swift/macOS開発スキルの向上
- ✅ モダンなUI/UXの実装

#### 学習目標
- ✅ Swift Concurrency の理解と実践
- ✅ SwiftUI + AppKit のハイブリッド開発
- ✅ データ永続化とエラーハンドリング
- ✅ 段階的開発プロセスの実践

#### 実用性
- ✅ 日常業務での実際の使用価値
- ✅ ユーザーフィードバックに基づく改善
- ✅ 継続的な機能拡張の基盤

### 今後の展望

#### 継続的改善
- ユーザーフィードバックに基づく機能追加
- パフォーマンスの継続的な最適化
- 新機能の段階的な実装

#### 技術的発展
- 最新macOS機能の積極的活用
- Swift言語の新機能の採用
- アーキテクチャの継続的な改善

#### コミュニティ
- オープンソース化による貢献
- 開発ノウハウの共有
- 技術コミュニティへの参加

---

## 📝 付録

### 開発環境
- **macOS**: 14.6.0
- **Xcode**: 15.0+
- **Swift**: 6.1
- **Swift Package Manager**: 6.1

### 主要な依存関係
- 外部ライブラリなし（標準ライブラリのみ使用）

### プロジェクト構造
```
swift_clipboard_app/
├── Package.swift
├── Sources/
│   ├── main.swift
│   ├── ClipboardManager.swift
│   ├── ClipboardItem.swift
│   ├── HistoryView.swift
│   ├── UIComponents.swift
│   └── Theme.swift
├── README.md
├── 調査レポート.md
├── docs/
│   └── MANUAL_TEST.md
└── logs/
    └── clipboard_log.txt
```

### 参考資料
- [Apple Developer Documentation](https://developer.apple.com/documentation/)
- [SwiftUI Tutorials](https://developer.apple.com/tutorials/swiftui)
- [AppKit Documentation](https://developer.apple.com/documentation/appkit)

---

**作成日**: [作成日を記入]  
**作成者**: [作成者名を記入]  
**バージョン**: 1.0
